#version 430
layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8, binding = 0) writeonly uniform image2D outputTexture;
layout(std430, binding = 0) buffer VoxelBuffer { int voxels[]; };
layout(std430, binding = 1) buffer ColorBuffer { uint colors[]; };

uniform vec3 cameraPos;
uniform vec3 lightDir;
uniform vec4 skyColor;
uniform vec4 lightColor;
uniform float voxelSize;
uniform int gridSize;

vec3 calculateNormal(vec3 voxelPos, vec3 rayDir) {
    vec3 local = rayDir;
    vec3 absLocal = abs(local);
    if (absLocal.x > absLocal.y && absLocal.x > absLocal.z)
        return vec3(sign(local.x), 0, 0);
    else if (absLocal.y > absLocal.z)
        return vec3(0, sign(local.y), 0);
    return vec3(0, 0, sign(local.z));
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(pixel) / vec2(imageSize(outputTexture)) * 2.0 - 1.0;
    uv.x *= float(imageSize(outputTexture).x) / float(imageSize(outputTexture).y);

    vec3 rayDir = normalize(vec3(uv, -1.0));
    vec3 rayPos = cameraPos;
    float t = 0.0;
    int steps = 0;
    const int MAX_STEPS = 100;

    while (steps < MAX_STEPS) {
        vec3 voxelPos = floor(rayPos / voxelSize);
        ivec3 idx = ivec3(voxelPos) + ivec3(gridSize / 2);

        if (idx.x >= 0 && idx.x < gridSize && idx.y >= 0 && idx.y < gridSize && idx.z >= 0 && idx.z < gridSize) {
            int voxelIndex = idx.x + idx.y * gridSize + idx.z * gridSize * gridSize;
            if (voxels[voxelIndex] == 1) {
                vec3 normal = calculateNormal(voxelPos, rayDir);
                float diffuse = max(0.0, dot(normal, -lightDir));
                uint color = colors[voxelIndex];
                vec4 baseColor = vec4(
                    float((color >> 24) & 0xFF) / 255.0,
                    float((color >> 16) & 0xFF) / 255.0,
                    float((color >> 8) & 0xFF) / 255.0,
                    float(color & 0xFF) / 255.0
                );
                vec4 finalColor = baseColor * diffuse * lightColor;
                imageStore(outputTexture, pixel, finalColor);
                return;
            }
        }

        t += voxelSize * 0.5;
        rayPos = cameraPos + t * rayDir;
        steps++;
    }

    imageStore(outputTexture, pixel, skyColor);
}
